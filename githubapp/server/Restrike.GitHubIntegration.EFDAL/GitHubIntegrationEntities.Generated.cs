//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 612
using System;
using System.Linq;
using System.Collections.Generic;
using Microsoft.EntityFrameworkCore;
using System.Configuration;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System.Threading.Tasks;
using System.Threading;
using System.Reflection;
using System.ComponentModel.DataAnnotations;

namespace Restrike.GitHubIntegration.EFDAL
{
	#region EntityMappingConstants Enumeration

	/// <summary>
	/// A map for all entity types in this library
	/// </summary>
	public enum EntityMappingConstants
	{
		/// <summary>
		/// A mapping for the the ConfigSetting entity
		/// </summary>
		ConfigSetting,
	}

	#endregion

	#region Entity Context

	/// <summary>
	/// The entity context for the defined model schema
	/// </summary>
	public partial class GitHubIntegrationEntities : Microsoft.EntityFrameworkCore.DbContext, IContext
	{
		private static Dictionary<string, bool> _mapAuditDateFields = new Dictionary<string, bool>();

		/// <summary />
		public static Action<string> QueryLogger { get; set; }

		/// <summary>
		/// A unique key for this object instance
		/// </summary>
		public Guid InstanceKey { get; private set; }

		private string _tenantId = null;
		/// <summary>
		/// The audit modifier used to mark database edits
		/// </summary>
		protected IContextStartup _contextStartup = new ContextStartup(null);

		private static object _seqCacheLock = new object();

		private const string _version = "0.0.0.0.1";
		private const string _modelKey = "708d9890-1cb1-4d50-be86-2f82697a5b95";
		protected string _connectionString = null;

		#region Constructors

		/// <summary>
	/// Initializes a new GitHubIntegrationEntities object using the connection string found in the 'GitHubIntegrationEntities' section of the application configuration file.
		/// </summary>
		public GitHubIntegrationEntities() :
			base()
		{
			_connectionString = ConfigurationManager.ConnectionStrings["GitHubIntegrationEntities"]?.ConnectionString;
			InstanceKey = Guid.NewGuid();
			_contextStartup = new ContextStartup(null, true);
			this.CommandTimeout = _contextStartup.CommandTimeout;
			this.OnContextCreated();
		}

		/// <summary>
		/// Initialize a new GitHubIntegrationEntities object with an audit modifier.
		/// </summary>
		public GitHubIntegrationEntities(IContextStartup contextStartup) :
				base()
		{
			_contextStartup = contextStartup;
			_tenantId = (this.ContextStartup as TenantContextStartup)?.TenantId;
			_connectionString = ConfigurationManager.ConnectionStrings["GitHubIntegrationEntities"]?.ConnectionString;
			InstanceKey = Guid.NewGuid();
			this.CommandTimeout = _contextStartup.CommandTimeout;
			this.OnContextCreated();
		}

		/// <summary>
	/// Initialize a new GitHubIntegrationEntities object with an audit modifier.
		/// </summary>
		public GitHubIntegrationEntities(IContextStartup contextStartup, string connectionString) :
				base()
		{
			_contextStartup = contextStartup;
			_tenantId = (this.ContextStartup as TenantContextStartup)?.TenantId;
			_connectionString = connectionString;
			InstanceKey = Guid.NewGuid();
			this.CommandTimeout = _contextStartup.CommandTimeout;
			this.OnContextCreated();
		}

		/// <summary>
		/// Initialize a new GitHubIntegrationEntities object with an audit modifier.
		/// </summary>
		public GitHubIntegrationEntities(string connectionString) :
				base()
		{
			_connectionString = connectionString;
			InstanceKey = Guid.NewGuid();
			_contextStartup = new ContextStartup(null, true);
			this.CommandTimeout = _contextStartup.CommandTimeout;
			this.OnContextCreated();
		}

		#endregion

		partial void OnContextCreated();
		partial void OnModelCreated(ModelBuilder modelBuilder);

		/// <summary>
		/// Model creation event
		/// </summary>
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
			base.OnModelCreating(modelBuilder);

			#region Map Tables
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().ToTable("ConfigSetting");
			#endregion

			#region Setup Fields

			//Field setup for ConfigSetting entity
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.ID).IsRequired(true).ValueGeneratedOnAdd();
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.Name).IsRequired(true).HasMaxLength(50);
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.Text).IsRequired(true);
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.CreatedDate).IsRequired();
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.ModifiedDate).IsRequired();
			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().Property(d => d.__concurrency).IsRequired();

			#endregion

			#region Ignore Enum Properties


			#endregion

			#region Primary Keys

			modelBuilder.Entity<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting>().HasKey(x => new { x.ID });

			#endregion

			#region Relations

			#endregion

            foreach (var eType in modelBuilder.Model.GetEntityTypes())
            {
                var tableType = eType.ClrType;
                var isTenant = tableType.GetInterfaces().Any(x => x == typeof(ITenantEntity));

                    #region Audit Fields
                    foreach (var prop in tableType.Props(false).Where(x => x.GetCustomAttributes(true).Any(z => z.GetType() != typeof(System.ComponentModel.DataAnnotations.Schema.NotMappedAttribute))))
                    {
                        //Created Date
                        var attr2 = prop.GetAttr<AuditCreatedDateAttribute>();
                        if (attr2 != null)
                        {
                            _mapAuditDateFields.Add($"{tableType.FullName}:{typeof(AuditCreatedDateAttribute).Name}", attr2.IsUTC);
                        }

                        //Modified Date
                        var attr4 = prop.GetAttr<AuditModifiedDateAttribute>();
                        if (attr4 != null)
                        {
                            _mapAuditDateFields.Add($"{tableType.FullName}:{typeof(AuditModifiedDateAttribute).Name}", attr4.IsUTC);
                        }

                        //Timestamp (default .NET attribute)
                        var attr6 = prop.GetAttr<System.ComponentModel.DataAnnotations.TimestampAttribute>();
                        if (attr6 != null)
                        {
                            throw new Exception($"Error on '{tableType.FullName}.{prop.Name}'. The 'Timestamp' attribute has been replaced with the 'ConcurrencyCheck' attribute.");
                        }
                    }
                    #endregion

                #region Handle the Tenant mappings
                if (isTenant)
                {
                    //Verify 
                    var startup = this.ContextStartup as TenantContextStartup;
                    if (startup == null)
                        throw new Exceptions.ContextConfigurationException("A tenant context must be created with a TenantContextStartup object.");

                    //https://haacked.com/archive/2019/07/29/query-filter-by-interface/
                    modelBuilder.SetEntityQueryFilter<ITenantEntity>(tableType, p => EF.Property<string>(p, "__tenant_user") == _tenantId);
                }
                #endregion
            }

			// Override this event in the partial class to add any custom model changes or validation
			this.OnModelCreated(modelBuilder);

		}

        private bool _inSave = false;
        public override Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!_inSave)
            {
                _inSave = true;
                try
                {
                    this.SetupSave();
                    return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
                }
                finally
                {
                    _inSave = false;
                }
            }
            else
                return base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            _inSave = true;
            try
            {
                this.SetupSave();
                return base.SaveChangesAsync(cancellationToken);
            }
            finally
            {
                _inSave = false;
            }
        }

        public override int SaveChanges(bool acceptAllChangesOnSuccess)
        {
            if (!_inSave)
            {
                _inSave = true;
                try
                {
                    this.SetupSave();
                    return base.SaveChanges(acceptAllChangesOnSuccess);
                }
                finally
                {
                    _inSave = false;
                }
            }
            else
                return base.SaveChanges(acceptAllChangesOnSuccess);
        }

        public override int SaveChanges()
        {
            _inSave = true;
            try
            {
                this.SetupSave();
                return base.SaveChanges();
            }
            finally
            {
                _inSave = false;
            }
        }

		protected virtual void SetupSave()
		{
            var markedTime = System.DateTime.Now;
            var markedTimeUtc = System.DateTime.UtcNow;
			var tenantId = (this.ContextStartup as TenantContextStartup)?.TenantId;

			//Get the added list
			var addedList = this.ChangeTracker.Entries().Where(x => x.State == EntityState.Added);
			//Process added list
			foreach (var item in addedList)
			{
                var isCreatedUtc = false;
                if (_mapAuditDateFields.ContainsKey($"{item.Entity}:{typeof(AuditCreatedDateAttribute).Name}"))
                    isCreatedUtc = _mapAuditDateFields[$"{item.Entity}:{typeof(AuditCreatedDateAttribute).Name}"];

                var isModifiedUtc = false;
                if (_mapAuditDateFields.ContainsKey($"{item.Entity}:{typeof(AuditModifiedDateAttribute).Name}"))
                    isModifiedUtc = _mapAuditDateFields[$"{item.Entity}:{typeof(AuditModifiedDateAttribute).Name}"];
                ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditCreatedByAttribute), this.ContextStartup.Modifier);
                ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditCreatedDateAttribute), isCreatedUtc ? markedTimeUtc : markedTime);
                ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditModifiedByAttribute), this.ContextStartup.Modifier);
                ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditModifiedDateAttribute), isModifiedUtc ? markedTimeUtc : markedTime);
                ReflectionHelpers.SetPropertyConcurrency(item, typeof(System.ComponentModel.DataAnnotations.ConcurrencyCheckAttribute));

				//Only set the TenantID on create. It never changes.
				if (item.Entity is ITenantEntity)
				{
					Util.SetPropertyByName(item.Entity, "__tenant_user", tenantId);
				}

			}

			//Process modified list
			var modifiedList = this.ChangeTracker.Entries().Where(x => x.State == EntityState.Modified);
			foreach (var item in modifiedList)
			{
              var isModifiedUtc = false;
              if (_mapAuditDateFields.ContainsKey($"{item.Entity}:{typeof(AuditModifiedDateAttribute).Name}"))
                  isModifiedUtc = _mapAuditDateFields[$"{item.Entity}:{typeof(AuditModifiedDateAttribute).Name}"];
				ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditModifiedByAttribute), this.ContextStartup.Modifier);
				ReflectionHelpers.SetPropertyByAttribute(item.Entity, typeof(AuditModifiedDateAttribute), isModifiedUtc ? markedTimeUtc : markedTime);
				ReflectionHelpers.SetPropertyConcurrency(item, typeof(System.ComponentModel.DataAnnotations.ConcurrencyCheckAttribute));
			}

		}

		#region Entity Sets

		/// <summary>
		/// Entity set for ConfigSetting
		/// </summary>
		public virtual DbSet<Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting> ConfigSetting { get; set; }

		#endregion

		/// <summary>
		/// The global settings of this context
		/// </summary>
		public virtual IContextStartup ContextStartup => _contextStartup;

		/// <summary>
		/// Determines the version of the model that created this library.
		/// </summary>
		public virtual string Version => _version;

		/// <summary>
		/// Determines the key of the model that created this library.
		/// </summary>
		public virtual string ModelKey => _modelKey;

        /// <summary>
        /// Back door add for immutable entities to be called for seed data
        /// </summary>
        internal EntityEntry AddImmutable(object entity)
        {
            return base.Add(entity);
        }

		#region AddItem Methods

        public override EntityEntry Add( object entity)
        {
            //No model validation. You should use the AddItem method.
            return base.Add(entity);
        }

        public override EntityEntry<TEntity> Add<TEntity>( TEntity entity)
        {
            //No model validation. You should use the AddItem method.
            return base.Add(entity);
        }

        public override void AddRange(IEnumerable<object> entities)
        {
            if (entities == null) return;
            //This will enforce model validation.
            foreach (var item in entities)
            {
                var entity = item as IBusinessObject;
                if (entity == null)
                    throw new Exception("Unknown entity type");
                this.AddItem(entity);
            }
        }

        public override void AddRange(params object[] entities)
        {
            this.AddRange(entities?.AsEnumerable());
        }

        public virtual void AddRange(IEnumerable<IBusinessObject> entities)
        {
            this.AddRange(entities?.AsEnumerable<object>());
        }

		/// <summary>
		/// Adds an entity of to the object context
		/// </summary>
		/// <param name="entity">The entity to add</param>
		public virtual T AddItem<T>(T entity) where T : class, IBusinessObject
		{
			if (entity == null) throw new NullReferenceException();
			ReflectionHelpers.SetPropertyByAttribute(entity, typeof(AuditCreatedByAttribute), this.ContextStartup.Modifier);
			ReflectionHelpers.SetPropertyByAttribute(entity, typeof(AuditModifiedByAttribute), this.ContextStartup.Modifier);
			if (false) { }
			else if (entity is Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting)
			{
				this.Add(entity);
			}
			else
			{
				//If not an entity then throw exception
				throw new Exception("Unknown entity type");
			}
			return entity;
		}

		#endregion

		#region RemoveItem Methods

        public override EntityEntry Remove(object entity)
        {
            //No model validation. You should use the RemoveItem method.
            return base.Remove(entity);
        }

        public override EntityEntry<TEntity> Remove<TEntity>(TEntity entity)
        {
            //No model validation. You should use the RemoveItem method.
            return base.Remove(entity);
        }

        public override void RemoveRange(IEnumerable<object> entities)
        {
            if (entities == null) return;
            foreach (var item in entities)
            {
                var entity = item as IBusinessObject;
                if (entity == null)
                    throw new Exception("Unknown entity type");
                this.RemoveItem(entity);
            }
        }

        public override void RemoveRange(params object[] entities)
        {
            this.RemoveRange(entities?.AsEnumerable());
        }

        public virtual void RemoveRange(IEnumerable<IBusinessObject> entities)
        {
            this.RemoveRange(entities?.AsEnumerable<object>());
        }

		/// <summary>
		/// Deletes an entity from the context
		/// </summary>
		/// <param name="entity">The entity to delete</param>
		public virtual void RemoveItem<T>(T entity) where T : class, IBusinessObject
		{
			if (entity == null) return;
			else this.Remove(entity);
		}

		#endregion

		#region Connection String
		/// <summary>
		/// Returns the connection string used for this context object
		/// </summary>
		public string ConnectionString
		{
			get
			{
				try
				{
					if (this.Database.GetDbConnection() != null && !string.IsNullOrEmpty(this.Database.GetDbConnection().ConnectionString))
						return this.Database.GetDbConnection().ConnectionString;
					else return null;
				}
				catch (Exception) { return null; }
			}
		}
		#endregion

		#region IContext Interface
		Enum IContext.GetEntityFromField(Enum field) => GetEntityFromField(field);
		#endregion

		#region GetEntityFromField

		/// <summary>
		/// Determines the entity from one of its fields
		/// </summary>
		public static EntityMappingConstants GetEntityFromField(Enum field)
		{
			if (field is Restrike.GitHubIntegration.EFDAL.Entity.ConfigSetting.FieldNameConstants) return Restrike.GitHubIntegration.EFDAL.EntityMappingConstants.ConfigSetting;
			throw new Exception("Unknown field type!");
		}

		#endregion

		#region Interface Extras

		/// <summary>
		/// Reloads the context object from database
		/// </summary>
		public void ReloadItem(IBusinessObject entity)
		{
			this.Entry(entity).Reload();
		}

		#endregion

		/// <summary>
		/// Determines the timeout of the database connection
		/// </summary>
		public int? CommandTimeout
		{
			get { return this.Database.GetCommandTimeout(); }
			set { 
				try { this.Database.SetCommandTimeout(value); }
				catch (System.InvalidOperationException ex) { if (!ex.Message.Contains("relational database")) throw; }
				catch { throw; }
			}
		}

	}
	#endregion

    public static class ContextExtensions
    {
        /// <summary>
        /// Load all enum tables and insert data
        /// </summary>
        public static void EnsureSeedData(this GitHubIntegrationEntities context)
        {
            //Get the assembly of the containing types
            var assembly = context.Model.GetEntityTypes().FirstOrDefault()?.ClrType?.Assembly;
            if (assembly == null) return;

            var allTypes = context.GetType()
                .GetProperties()
                .Where(pi => pi.PropertyType.IsGenericType && pi.PropertyType.GetGenericTypeDefinition() == typeof(DbSet<>))
                .SelectMany(x => x.PropertyType.GenericTypeArguments)
                .ToList();

            foreach (var mytype in ReflectionHelpers.GetTypesWithAttribute(allTypes, typeof(StaticDataAttribute)))
            {
                var enumMap = mytype.GetAttr<StaticDataAttribute>();
                var key = mytype
                    .GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)
                    .FirstOrDefault(x => Enumerable.Any<object>(x.GetCustomAttributes(true), z => z.GetType() != typeof(KeyAttribute)));

                var entities = ReflectionHelpers.BuildEntityObjectsFromEnum(mytype, enumMap.ParentType);
                try
                {
                    foreach (var entity in entities)
                    {
                        // attempt to load the existing item from the database
                        var entry = context.Entry(entity);
                        entry.Reload();

                        if (entry.State == EntityState.Detached)
                        {
                            // if it doesn't yet exist, add it as normal
                            context.AddImmutable(entity);
                        }
                        else
                        {
                            // otherwise update its values as the enum name may have changed etc
                            entry.CurrentValues.SetValues(entity);
                        }
                    }
                    context.SaveChanges();
                }
                catch (Exception ex)
                {
                    //TODO: Handle duplicates, second runs
                }
            }
        }

    }
}

namespace Restrike.GitHubIntegration.EFDAL.Entity
{
}
#pragma warning restore 612
